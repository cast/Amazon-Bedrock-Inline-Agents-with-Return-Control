"""
Lambda function for handling Bedrock Agent requests.
Generated by Bedrock Agents SDK with fixes for parameter handling.
"""
import json
import logging
import datetime
import bs4
import duckduckgo_search
import requests

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Function implementations

def search_internet(query: str, num_results: int = 5) -> dict:
    """
    Search the internet using DuckDuckGo
    
    Args:
        query: The search query
        num_results: Number of results to return (default: 5)
        
    Returns:
        Dictionary containing search results
    """
    from duckduckgo_search import DDGS
    try:
        # Create a DuckDuckGo Search instance
        ddg = DDGS()
        
        # Perform the search
        search_results = list(ddg.text(query, max_results=num_results))
        
        # Format the results - handle different possible return formats
        results = []
        for result in search_results:
            # Check if result is a dictionary (newer versions of the library)
            if isinstance(result, dict):
                results.append({
                    "title": result.get('title', ''),
                    "url": result.get('href', ''),
                    "snippet": result.get('body', '')
                })
            # Check if result is a list or tuple (older versions or different format)
            elif isinstance(result, (list, tuple)) and len(result) >= 3:
                results.append({
                    "title": result[0] if len(result) > 0 else '',
                    "url": result[1] if len(result) > 1 else '',
                    "snippet": result[2] if len(result) > 2 else ''
                })
            # Fallback for any other format
            else:
                results.append({
                    "title": str(result),
                    "url": "",
                    "snippet": str(result)
                })
                
        return {
            "results": results,
            "query": query
        }
    except Exception as e:
        logger.error(f"Search error: {str(e)}")
        # Return error information if the search fails
        return {
            "results": [],
            "query": query,
            "error": str(e)
        }


def load_text_from_url(url: str) -> dict:
    """
    Load and extract text content from a specified URL
    
    Args:
        url: The URL to fetch text content from
        
    Returns:
        Dictionary containing the extracted text
    """
    from bs4 import BeautifulSoup
    import requests
    try:
        # Add user agent to avoid being blocked
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()  # Raise exception for 4XX/5XX responses
        
        # Parse the HTML content
        soup = BeautifulSoup(response.text, 'html.parser')
        
        # Remove script and style elements
        for script_or_style in soup(["script", "style", "header", "footer", "nav"]):
            script_or_style.extract()
            
        # Get text content
        text = soup.get_text()
        
        # Clean up text: remove extra whitespace and blank lines
        lines = (line.strip() for line in text.splitlines())
        chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
        text = '\n'.join(chunk for chunk in chunks if chunk)
        
        # Limit text length to avoid exceeding Lambda response size limits
        max_length = 100000  # Adjust as needed
        if len(text) > max_length:
            text = text[:max_length] + "... [content truncated due to size]"
        
        return {
            "content": text,
            "url": url,
            "status_code": response.status_code
        }
    except Exception as e:
        logger.error(f"URL loading error: {str(e)}")
        # Handle errors gracefully
        return {
            "content": f"Error retrieving content: {str(e)}",
            "url": url,
            "status_code": 500
        }

def extract_parameter_value(parameters, param_name, default=None):
    """
    Extract a parameter value from the parameters list
    
    Args:
        parameters: List of parameter dictionaries
        param_name: Name of the parameter to extract
        default: Default value if parameter is not found
        
    Returns:
        The parameter value or default if not found
    """
    if isinstance(parameters, list):
        # Parameters is a list of dictionaries
        for param in parameters:
            if isinstance(param, dict) and param.get('name') == param_name:
                return param.get('value', default)
    elif isinstance(parameters, dict):
        # Parameters is a dictionary
        return parameters.get(param_name, default)
    
    # If we get here, parameter was not found
    return default

def lambda_handler(event, context):
    """
    Lambda function handler for Bedrock Agent requests
    """
    logger.info("Received event: %s", json.dumps(event))
    
    try:
        # Extract information from the event
        message_version = event.get("messageVersion", "1.0")
        function_name = event.get("function", "")
        action_group = event.get("actionGroup", "")
        
        # Get parameters from the event if available
        parameters = event.get("parameters", [])
        logger.info(f"Parameters received: {parameters}")
        
        # Call the appropriate function based on the function name
        if function_name == "search_internet":
            # Extract parameters using the helper function
            query = extract_parameter_value(parameters, "query", "")
            num_results_str = extract_parameter_value(parameters, "num_results", "5")
            
            # Convert num_results to integer
            try:
                num_results = int(num_results_str)
            except (ValueError, TypeError):
                num_results = 5
            
            logger.info(f"Calling search_internet with query='{query}', num_results={num_results}")
            output_from_logic = search_internet(query=query, num_results=num_results)
            
            # Format the response
            response_body = {
                "TEXT": {
                    "body": json.dumps(output_from_logic)
                }
            }
            
            action_response = {
                "actionGroup": action_group,
                "function": function_name,
                "functionResponse": {
                    "responseBody": response_body
                }
            }
            
            function_response = {
                "response": action_response,
                "messageVersion": message_version
            }
            
            return function_response
        if function_name == "load_text_from_url":
            # Extract parameters using the helper function
            url = extract_parameter_value(parameters, "url", "")
            
            logger.info(f"Calling load_text_from_url with url='{url}'")
            output_from_logic = load_text_from_url(url=url)
            
            # Format the response
            response_body = {
                "TEXT": {
                    "body": json.dumps(output_from_logic)
                }
            }
            
            action_response = {
                "actionGroup": action_group,
                "function": function_name,
                "functionResponse": {
                    "responseBody": response_body
                }
            }
            
            function_response = {
                "response": action_response,
                "messageVersion": message_version
            }
            
            return function_response
        # If we get here, the function was not found
        logger.error("Unknown function: %s", function_name)
        error_message = f"Unknown function: {function_name}"
        
        response_body = {
            "TEXT": {
                "body": json.dumps({"error": error_message})
            }
        }
        
        action_response = {
            "actionGroup": action_group,
            "function": function_name,
            "functionResponse": {
                "responseBody": response_body
            }
        }
        
        function_response = {
            "response": action_response,
            "messageVersion": message_version
        }
        
        return function_response
        
    except Exception as e:
        logger.error("Error processing request: %s", str(e))
        error_message = str(e)
        
        # Extract action group and function name from event if available
        action_group = event.get("actionGroup", "")
        function_name = event.get("function", "")
        message_version = event.get("messageVersion", "1.0")
        
        response_body = {
            "TEXT": {
                "body": json.dumps({"error": error_message})
            }
        }
        
        action_response = {
            "actionGroup": action_group,
            "function": function_name,
            "functionResponse": {
                "responseBody": response_body
            }
        }
        
        function_response = {
            "response": action_response,
            "messageVersion": message_version
        }
        
        return function_response 